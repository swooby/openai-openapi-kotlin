/**
 * Please note: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). Do not edit this file manually.
 */
@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport",
)

package com.openai.apis

import com.openai.infrastructure.ApiClient
import com.openai.infrastructure.ApiResponse
import com.openai.infrastructure.ClientError
import com.openai.infrastructure.ClientException
import com.openai.infrastructure.MultiValueMap
import com.openai.infrastructure.PartConfig
import com.openai.infrastructure.RequestConfig
import com.openai.infrastructure.RequestMethod
import com.openai.infrastructure.ResponseType
import com.openai.infrastructure.ServerError
import com.openai.infrastructure.ServerException
import com.openai.infrastructure.Success
import com.openai.models.DeleteFileResponse
import com.openai.models.ListFilesResponse
import com.openai.models.OpenAIFile
import com.squareup.moshi.Json
import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

class FilesApi(
    basePath: kotlin.String = defaultBasePath,
    client: Call.Factory = ApiClient.defaultClient,
) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties()
                .getProperty(ApiClient.baseUrlKey, "https://api.openai.com/v1")
        }
    }

    /** enum for parameter purpose */
    enum class PurposeCreateFile(val value: kotlin.String) {
        @Json(name = "assistants") assistants("assistants"),
        @Json(name = "batch") batch("batch"),
        @Json(name = "fine-tune") fineMinusTune("fine-tune"),
        @Json(name = "vision") vision("vision");

        /**
         * Override [toString()] to avoid using the enum variable name as the
         * value, and instead use the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are
         * different, and ensures that the client sends the correct enum values
         * to the server always.
         */
        override fun toString(): kotlin.String = "$value"
    }

    /**
     * Upload a file that can be used across various endpoints. Individual files
     * can be up to 512 MB, and the size of all files uploaded by one
     * organization can be up to 100 GB. The Assistants API supports files up to
     * 2 million tokens and of specific file types. See the
     * [Assistants Tools guide](/docs/assistants/tools) for details. The
     * Fine-tuning API only supports &#x60;.jsonl&#x60; files. The input also
     * has certain required formats for fine-tuning
     * [chat](/docs/api-reference/fine-tuning/chat-input) or
     * [completions](/docs/api-reference/fine-tuning/completions-input) models.
     * The Batch API only supports &#x60;.jsonl&#x60; files up to 200 MB in
     * size. The input also has a specific required
     * [format](/docs/api-reference/batch/request-input). Please
     * [contact us](https://help.openai.com/) if you need to increase these
     * storage limits.
     *
     * @param file The File object (not file name) to be uploaded.
     * @param purpose The intended purpose of the uploaded file. Use
     *   \\\&quot;assistants\\\&quot; for
     *   [Assistants](/docs/api-reference/assistants) and
     *   [Message](/docs/api-reference/messages) files, \\\&quot;vision\\\&quot;
     *   for Assistants image file inputs, \\\&quot;batch\\\&quot; for
     *   [Batch API](/docs/guides/batch), and \\\&quot;fine-tune\\\&quot; for
     *   [Fine-tuning](/docs/api-reference/fine-tuning).
     * @return OpenAIFile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun createFile(file: java.io.File, purpose: PurposeCreateFile): OpenAIFile {
        val localVarResponse =
            createFileWithHttpInfo(file = file, purpose = purpose)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as OpenAIFile
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Upload a file that can be used across various endpoints. Individual files
     * can be up to 512 MB, and the size of all files uploaded by one
     * organization can be up to 100 GB. The Assistants API supports files up to
     * 2 million tokens and of specific file types. See the
     * [Assistants Tools guide](/docs/assistants/tools) for details. The
     * Fine-tuning API only supports &#x60;.jsonl&#x60; files. The input also
     * has certain required formats for fine-tuning
     * [chat](/docs/api-reference/fine-tuning/chat-input) or
     * [completions](/docs/api-reference/fine-tuning/completions-input) models.
     * The Batch API only supports &#x60;.jsonl&#x60; files up to 200 MB in
     * size. The input also has a specific required
     * [format](/docs/api-reference/batch/request-input). Please
     * [contact us](https://help.openai.com/) if you need to increase these
     * storage limits.
     *
     * @param file The File object (not file name) to be uploaded.
     * @param purpose The intended purpose of the uploaded file. Use
     *   \\\&quot;assistants\\\&quot; for
     *   [Assistants](/docs/api-reference/assistants) and
     *   [Message](/docs/api-reference/messages) files, \\\&quot;vision\\\&quot;
     *   for Assistants image file inputs, \\\&quot;batch\\\&quot; for
     *   [Batch API](/docs/guides/batch), and \\\&quot;fine-tune\\\&quot; for
     *   [Fine-tuning](/docs/api-reference/fine-tuning).
     * @return ApiResponse<OpenAIFile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createFileWithHttpInfo(
        file: java.io.File,
        purpose: PurposeCreateFile,
    ): ApiResponse<OpenAIFile?> {
        val localVariableConfig =
            createFileRequestConfig(file = file, purpose = purpose)

        return request<Map<String, PartConfig<*>>, OpenAIFile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createFile
     *
     * @param file The File object (not file name) to be uploaded.
     * @param purpose The intended purpose of the uploaded file. Use
     *   \\\&quot;assistants\\\&quot; for
     *   [Assistants](/docs/api-reference/assistants) and
     *   [Message](/docs/api-reference/messages) files, \\\&quot;vision\\\&quot;
     *   for Assistants image file inputs, \\\&quot;batch\\\&quot; for
     *   [Batch API](/docs/guides/batch), and \\\&quot;fine-tune\\\&quot; for
     *   [Fine-tuning](/docs/api-reference/fine-tuning).
     * @return RequestConfig
     */
    fun createFileRequestConfig(
        file: java.io.File,
        purpose: PurposeCreateFile,
    ): RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody =
            mapOf(
                "file" to PartConfig(body = file, headers = mutableMapOf()),
                "purpose" to
                    PartConfig(body = purpose.value, headers = mutableMapOf()),
            )
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> =
            mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Delete a file.
     *
     * @param fileId The ID of the file to use for this request.
     * @return DeleteFileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun deleteFile(fileId: kotlin.String): DeleteFileResponse {
        val localVarResponse = deleteFileWithHttpInfo(fileId = fileId)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as DeleteFileResponse
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Delete a file.
     *
     * @param fileId The ID of the file to use for this request.
     * @return ApiResponse<DeleteFileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteFileWithHttpInfo(
        fileId: kotlin.String
    ): ApiResponse<DeleteFileResponse?> {
        val localVariableConfig = deleteFileRequestConfig(fileId = fileId)

        return request<Unit, DeleteFileResponse>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation deleteFile
     *
     * @param fileId The ID of the file to use for this request.
     * @return RequestConfig
     */
    fun deleteFileRequestConfig(fileId: kotlin.String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path =
                "/files/{file_id}"
                    .replace(
                        "{" + "file_id" + "}",
                        encodeURIComponent(fileId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Returns the contents of the specified file.
     *
     * @param fileId The ID of the file to use for this request.
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun downloadFile(fileId: kotlin.String): kotlin.String {
        val localVarResponse = downloadFileWithHttpInfo(fileId = fileId)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Returns the contents of the specified file.
     *
     * @param fileId The ID of the file to use for this request.
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun downloadFileWithHttpInfo(
        fileId: kotlin.String
    ): ApiResponse<kotlin.String?> {
        val localVariableConfig = downloadFileRequestConfig(fileId = fileId)

        return request<Unit, kotlin.String>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation downloadFile
     *
     * @param fileId The ID of the file to use for this request.
     * @return RequestConfig
     */
    fun downloadFileRequestConfig(fileId: kotlin.String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path =
                "/files/{file_id}/content"
                    .replace(
                        "{" + "file_id" + "}",
                        encodeURIComponent(fileId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /** enum for parameter order */
    enum class OrderListFiles(val value: kotlin.String) {
        @Json(name = "asc") asc("asc"),
        @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the
         * value, and instead use the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are
         * different, and ensures that the client sends the correct enum values
         * to the server always.
         */
        override fun toString(): kotlin.String = "$value"
    }

    /**
     * Returns a list of files.
     *
     * @param purpose Only return files with the given purpose. (optional)
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 10,000, and the default is 10,000. (optional,
     *   default to 10000)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @return ListFilesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun listFiles(
        purpose: kotlin.String? = null,
        limit: kotlin.Int? = 10000,
        order: OrderListFiles? = OrderListFiles.desc,
        after: kotlin.String? = null,
    ): ListFilesResponse {
        val localVarResponse =
            listFilesWithHttpInfo(
                purpose = purpose,
                limit = limit,
                order = order,
                after = after,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as ListFilesResponse
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Returns a list of files.
     *
     * @param purpose Only return files with the given purpose. (optional)
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 10,000, and the default is 10,000. (optional,
     *   default to 10000)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @return ApiResponse<ListFilesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listFilesWithHttpInfo(
        purpose: kotlin.String?,
        limit: kotlin.Int?,
        order: OrderListFiles?,
        after: kotlin.String?,
    ): ApiResponse<ListFilesResponse?> {
        val localVariableConfig =
            listFilesRequestConfig(
                purpose = purpose,
                limit = limit,
                order = order,
                after = after,
            )

        return request<Unit, ListFilesResponse>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation listFiles
     *
     * @param purpose Only return files with the given purpose. (optional)
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 10,000, and the default is 10,000. (optional,
     *   default to 10000)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @return RequestConfig
     */
    fun listFilesRequestConfig(
        purpose: kotlin.String?,
        limit: kotlin.Int?,
        order: OrderListFiles?,
        after: kotlin.String?,
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap =
            mutableMapOf<
                    kotlin.String,
                    kotlin.collections.List<kotlin.String>,
                >()
                .apply {
                    if (purpose != null) {
                        put("purpose", listOf(purpose.toString()))
                    }
                    if (limit != null) {
                        put("limit", listOf(limit.toString()))
                    }
                    if (order != null) {
                        put("order", listOf(order.value))
                    }
                    if (after != null) {
                        put("after", listOf(after.toString()))
                    }
                }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/files",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Returns information about a specific file.
     *
     * @param fileId The ID of the file to use for this request.
     * @return OpenAIFile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun retrieveFile(fileId: kotlin.String): OpenAIFile {
        val localVarResponse = retrieveFileWithHttpInfo(fileId = fileId)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as OpenAIFile
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Returns information about a specific file.
     *
     * @param fileId The ID of the file to use for this request.
     * @return ApiResponse<OpenAIFile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun retrieveFileWithHttpInfo(
        fileId: kotlin.String
    ): ApiResponse<OpenAIFile?> {
        val localVariableConfig = retrieveFileRequestConfig(fileId = fileId)

        return request<Unit, OpenAIFile>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation retrieveFile
     *
     * @param fileId The ID of the file to use for this request.
     * @return RequestConfig
     */
    fun retrieveFileRequestConfig(fileId: kotlin.String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path =
                "/files/{file_id}"
                    .replace(
                        "{" + "file_id" + "}",
                        encodeURIComponent(fileId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder()
            .scheme("http")
            .host("localhost")
            .addPathSegment(uriComponent)
            .build()
            .encodedPathSegments[0]
}
