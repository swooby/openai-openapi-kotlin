/**
 * Please note: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). Do not edit this file manually.
 */
@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport",
)

package com.openai.apis

import com.openai.infrastructure.ApiClient
import com.openai.infrastructure.ApiResponse
import com.openai.infrastructure.ClientError
import com.openai.infrastructure.ClientException
import com.openai.infrastructure.MultiValueMap
import com.openai.infrastructure.RequestConfig
import com.openai.infrastructure.RequestMethod
import com.openai.infrastructure.ResponseType
import com.openai.infrastructure.ServerError
import com.openai.infrastructure.ServerException
import com.openai.infrastructure.Success
import com.openai.models.Batch
import com.openai.models.CreateBatchRequest
import com.openai.models.ListBatchesResponse
import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

class BatchApi(
    basePath: kotlin.String = defaultBasePath,
    client: Call.Factory = ApiClient.defaultClient,
) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties()
                .getProperty(ApiClient.baseUrlKey, "https://api.openai.com/v1")
        }
    }

    /**
     * Cancels an in-progress batch. The batch will be in status
     * &#x60;cancelling&#x60; for up to 10 minutes, before changing to
     * &#x60;cancelled&#x60;, where it will have partial results (if any)
     * available in the output file.
     *
     * @param batchId The ID of the batch to cancel.
     * @return Batch
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun cancelBatch(batchId: kotlin.String): Batch {
        val localVarResponse = cancelBatchWithHttpInfo(batchId = batchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as Batch
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Cancels an in-progress batch. The batch will be in status
     * &#x60;cancelling&#x60; for up to 10 minutes, before changing to
     * &#x60;cancelled&#x60;, where it will have partial results (if any)
     * available in the output file.
     *
     * @param batchId The ID of the batch to cancel.
     * @return ApiResponse<Batch?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cancelBatchWithHttpInfo(batchId: kotlin.String): ApiResponse<Batch?> {
        val localVariableConfig = cancelBatchRequestConfig(batchId = batchId)

        return request<Unit, Batch>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation cancelBatch
     *
     * @param batchId The ID of the batch to cancel.
     * @return RequestConfig
     */
    fun cancelBatchRequestConfig(batchId: kotlin.String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path =
                "/batches/{batch_id}/cancel"
                    .replace(
                        "{" + "batch_id" + "}",
                        encodeURIComponent(batchId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Creates and executes a batch from an uploaded file of requests
     *
     * @param createBatchRequest
     * @return Batch
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun createBatch(createBatchRequest: CreateBatchRequest): Batch {
        val localVarResponse =
            createBatchWithHttpInfo(createBatchRequest = createBatchRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as Batch
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Creates and executes a batch from an uploaded file of requests
     *
     * @param createBatchRequest
     * @return ApiResponse<Batch?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createBatchWithHttpInfo(
        createBatchRequest: CreateBatchRequest
    ): ApiResponse<Batch?> {
        val localVariableConfig =
            createBatchRequestConfig(createBatchRequest = createBatchRequest)

        return request<CreateBatchRequest, Batch>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation createBatch
     *
     * @param createBatchRequest
     * @return RequestConfig
     */
    fun createBatchRequestConfig(
        createBatchRequest: CreateBatchRequest
    ): RequestConfig<CreateBatchRequest> {
        val localVariableBody = createBatchRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/batches",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * List your organization&#39;s batches.
     *
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @return ListBatchesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun listBatches(
        after: kotlin.String? = null,
        limit: kotlin.Int? = 20,
    ): ListBatchesResponse {
        val localVarResponse =
            listBatchesWithHttpInfo(after = after, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as ListBatchesResponse
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * List your organization&#39;s batches.
     *
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @return ApiResponse<ListBatchesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listBatchesWithHttpInfo(
        after: kotlin.String?,
        limit: kotlin.Int?,
    ): ApiResponse<ListBatchesResponse?> {
        val localVariableConfig =
            listBatchesRequestConfig(after = after, limit = limit)

        return request<Unit, ListBatchesResponse>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation listBatches
     *
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @return RequestConfig
     */
    fun listBatchesRequestConfig(
        after: kotlin.String?,
        limit: kotlin.Int?,
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap =
            mutableMapOf<
                    kotlin.String,
                    kotlin.collections.List<kotlin.String>,
                >()
                .apply {
                    if (after != null) {
                        put("after", listOf(after.toString()))
                    }
                    if (limit != null) {
                        put("limit", listOf(limit.toString()))
                    }
                }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/batches",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Retrieves a batch.
     *
     * @param batchId The ID of the batch to retrieve.
     * @return Batch
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun retrieveBatch(batchId: kotlin.String): Batch {
        val localVarResponse = retrieveBatchWithHttpInfo(batchId = batchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as Batch
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Retrieves a batch.
     *
     * @param batchId The ID of the batch to retrieve.
     * @return ApiResponse<Batch?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun retrieveBatchWithHttpInfo(batchId: kotlin.String): ApiResponse<Batch?> {
        val localVariableConfig = retrieveBatchRequestConfig(batchId = batchId)

        return request<Unit, Batch>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation retrieveBatch
     *
     * @param batchId The ID of the batch to retrieve.
     * @return RequestConfig
     */
    fun retrieveBatchRequestConfig(
        batchId: kotlin.String
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path =
                "/batches/{batch_id}"
                    .replace(
                        "{" + "batch_id" + "}",
                        encodeURIComponent(batchId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder()
            .scheme("http")
            .host("localhost")
            .addPathSegment(uriComponent)
            .build()
            .encodedPathSegments[0]
}
