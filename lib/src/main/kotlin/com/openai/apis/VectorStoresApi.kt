/**
 * Please note: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). Do not edit this file manually.
 */
@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport",
)

package com.openai.apis

import com.openai.infrastructure.ApiClient
import com.openai.infrastructure.ApiResponse
import com.openai.infrastructure.ClientError
import com.openai.infrastructure.ClientException
import com.openai.infrastructure.MultiValueMap
import com.openai.infrastructure.RequestConfig
import com.openai.infrastructure.RequestMethod
import com.openai.infrastructure.ResponseType
import com.openai.infrastructure.ServerError
import com.openai.infrastructure.ServerException
import com.openai.infrastructure.Success
import com.openai.models.CreateVectorStoreFileBatchRequest
import com.openai.models.CreateVectorStoreFileRequest
import com.openai.models.CreateVectorStoreRequest
import com.openai.models.DeleteVectorStoreFileResponse
import com.openai.models.DeleteVectorStoreResponse
import com.openai.models.ListVectorStoreFilesResponse
import com.openai.models.ListVectorStoresResponse
import com.openai.models.UpdateVectorStoreRequest
import com.openai.models.VectorStoreFileBatchObject
import com.openai.models.VectorStoreFileObject
import com.openai.models.VectorStoreObject
import com.squareup.moshi.Json
import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

class VectorStoresApi(
    basePath: kotlin.String = defaultBasePath,
    client: Call.Factory = ApiClient.defaultClient,
) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties()
                .getProperty(ApiClient.baseUrlKey, "https://api.openai.com/v1")
        }
    }

    /**
     * Cancel a vector store file batch. This attempts to cancel the processing
     * of files in this batch as soon as possible.
     *
     * @param vectorStoreId The ID of the vector store that the file batch
     *   belongs to.
     * @param batchId The ID of the file batch to cancel.
     * @return VectorStoreFileBatchObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun cancelVectorStoreFileBatch(
        vectorStoreId: kotlin.String,
        batchId: kotlin.String,
    ): VectorStoreFileBatchObject {
        val localVarResponse =
            cancelVectorStoreFileBatchWithHttpInfo(
                vectorStoreId = vectorStoreId,
                batchId = batchId,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data
                    as VectorStoreFileBatchObject
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Cancel a vector store file batch. This attempts to cancel the processing
     * of files in this batch as soon as possible.
     *
     * @param vectorStoreId The ID of the vector store that the file batch
     *   belongs to.
     * @param batchId The ID of the file batch to cancel.
     * @return ApiResponse<VectorStoreFileBatchObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cancelVectorStoreFileBatchWithHttpInfo(
        vectorStoreId: kotlin.String,
        batchId: kotlin.String,
    ): ApiResponse<VectorStoreFileBatchObject?> {
        val localVariableConfig =
            cancelVectorStoreFileBatchRequestConfig(
                vectorStoreId = vectorStoreId,
                batchId = batchId,
            )

        return request<Unit, VectorStoreFileBatchObject>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation cancelVectorStoreFileBatch
     *
     * @param vectorStoreId The ID of the vector store that the file batch
     *   belongs to.
     * @param batchId The ID of the file batch to cancel.
     * @return RequestConfig
     */
    fun cancelVectorStoreFileBatchRequestConfig(
        vectorStoreId: kotlin.String,
        batchId: kotlin.String,
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path =
                "/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    )
                    .replace(
                        "{" + "batch_id" + "}",
                        encodeURIComponent(batchId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Create a vector store.
     *
     * @param createVectorStoreRequest
     * @return VectorStoreObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun createVectorStore(
        createVectorStoreRequest: CreateVectorStoreRequest
    ): VectorStoreObject {
        val localVarResponse =
            createVectorStoreWithHttpInfo(
                createVectorStoreRequest = createVectorStoreRequest
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as VectorStoreObject
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Create a vector store.
     *
     * @param createVectorStoreRequest
     * @return ApiResponse<VectorStoreObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createVectorStoreWithHttpInfo(
        createVectorStoreRequest: CreateVectorStoreRequest
    ): ApiResponse<VectorStoreObject?> {
        val localVariableConfig =
            createVectorStoreRequestConfig(
                createVectorStoreRequest = createVectorStoreRequest
            )

        return request<CreateVectorStoreRequest, VectorStoreObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createVectorStore
     *
     * @param createVectorStoreRequest
     * @return RequestConfig
     */
    fun createVectorStoreRequestConfig(
        createVectorStoreRequest: CreateVectorStoreRequest
    ): RequestConfig<CreateVectorStoreRequest> {
        val localVariableBody = createVectorStoreRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/vector_stores",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Create a vector store file by attaching a
     * [File](/docs/api-reference/files) to a
     * [vector store](/docs/api-reference/vector-stores/object).
     *
     * @param vectorStoreId The ID of the vector store for which to create a
     *   File.
     * @param createVectorStoreFileRequest
     * @return VectorStoreFileObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun createVectorStoreFile(
        vectorStoreId: kotlin.String,
        createVectorStoreFileRequest: CreateVectorStoreFileRequest,
    ): VectorStoreFileObject {
        val localVarResponse =
            createVectorStoreFileWithHttpInfo(
                vectorStoreId = vectorStoreId,
                createVectorStoreFileRequest = createVectorStoreFileRequest,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as VectorStoreFileObject
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Create a vector store file by attaching a
     * [File](/docs/api-reference/files) to a
     * [vector store](/docs/api-reference/vector-stores/object).
     *
     * @param vectorStoreId The ID of the vector store for which to create a
     *   File.
     * @param createVectorStoreFileRequest
     * @return ApiResponse<VectorStoreFileObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createVectorStoreFileWithHttpInfo(
        vectorStoreId: kotlin.String,
        createVectorStoreFileRequest: CreateVectorStoreFileRequest,
    ): ApiResponse<VectorStoreFileObject?> {
        val localVariableConfig =
            createVectorStoreFileRequestConfig(
                vectorStoreId = vectorStoreId,
                createVectorStoreFileRequest = createVectorStoreFileRequest,
            )

        return request<CreateVectorStoreFileRequest, VectorStoreFileObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createVectorStoreFile
     *
     * @param vectorStoreId The ID of the vector store for which to create a
     *   File.
     * @param createVectorStoreFileRequest
     * @return RequestConfig
     */
    fun createVectorStoreFileRequestConfig(
        vectorStoreId: kotlin.String,
        createVectorStoreFileRequest: CreateVectorStoreFileRequest,
    ): RequestConfig<CreateVectorStoreFileRequest> {
        val localVariableBody = createVectorStoreFileRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path =
                "/vector_stores/{vector_store_id}/files"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Create a vector store file batch.
     *
     * @param vectorStoreId The ID of the vector store for which to create a
     *   File Batch.
     * @param createVectorStoreFileBatchRequest
     * @return VectorStoreFileBatchObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun createVectorStoreFileBatch(
        vectorStoreId: kotlin.String,
        createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest,
    ): VectorStoreFileBatchObject {
        val localVarResponse =
            createVectorStoreFileBatchWithHttpInfo(
                vectorStoreId = vectorStoreId,
                createVectorStoreFileBatchRequest =
                    createVectorStoreFileBatchRequest,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data
                    as VectorStoreFileBatchObject
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Create a vector store file batch.
     *
     * @param vectorStoreId The ID of the vector store for which to create a
     *   File Batch.
     * @param createVectorStoreFileBatchRequest
     * @return ApiResponse<VectorStoreFileBatchObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createVectorStoreFileBatchWithHttpInfo(
        vectorStoreId: kotlin.String,
        createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest,
    ): ApiResponse<VectorStoreFileBatchObject?> {
        val localVariableConfig =
            createVectorStoreFileBatchRequestConfig(
                vectorStoreId = vectorStoreId,
                createVectorStoreFileBatchRequest =
                    createVectorStoreFileBatchRequest,
            )

        return request<
            CreateVectorStoreFileBatchRequest,
            VectorStoreFileBatchObject,
        >(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createVectorStoreFileBatch
     *
     * @param vectorStoreId The ID of the vector store for which to create a
     *   File Batch.
     * @param createVectorStoreFileBatchRequest
     * @return RequestConfig
     */
    fun createVectorStoreFileBatchRequestConfig(
        vectorStoreId: kotlin.String,
        createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest,
    ): RequestConfig<CreateVectorStoreFileBatchRequest> {
        val localVariableBody = createVectorStoreFileBatchRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path =
                "/vector_stores/{vector_store_id}/file_batches"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Delete a vector store.
     *
     * @param vectorStoreId The ID of the vector store to delete.
     * @return DeleteVectorStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun deleteVectorStore(
        vectorStoreId: kotlin.String
    ): DeleteVectorStoreResponse {
        val localVarResponse =
            deleteVectorStoreWithHttpInfo(vectorStoreId = vectorStoreId)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data
                    as DeleteVectorStoreResponse
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Delete a vector store.
     *
     * @param vectorStoreId The ID of the vector store to delete.
     * @return ApiResponse<DeleteVectorStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteVectorStoreWithHttpInfo(
        vectorStoreId: kotlin.String
    ): ApiResponse<DeleteVectorStoreResponse?> {
        val localVariableConfig =
            deleteVectorStoreRequestConfig(vectorStoreId = vectorStoreId)

        return request<Unit, DeleteVectorStoreResponse>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation deleteVectorStore
     *
     * @param vectorStoreId The ID of the vector store to delete.
     * @return RequestConfig
     */
    fun deleteVectorStoreRequestConfig(
        vectorStoreId: kotlin.String
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path =
                "/vector_stores/{vector_store_id}"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Delete a vector store file. This will remove the file from the vector
     * store but the file itself will not be deleted. To delete the file, use
     * the [delete file](/docs/api-reference/files/delete) endpoint.
     *
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file to delete.
     * @return DeleteVectorStoreFileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun deleteVectorStoreFile(
        vectorStoreId: kotlin.String,
        fileId: kotlin.String,
    ): DeleteVectorStoreFileResponse {
        val localVarResponse =
            deleteVectorStoreFileWithHttpInfo(
                vectorStoreId = vectorStoreId,
                fileId = fileId,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data
                    as DeleteVectorStoreFileResponse
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Delete a vector store file. This will remove the file from the vector
     * store but the file itself will not be deleted. To delete the file, use
     * the [delete file](/docs/api-reference/files/delete) endpoint.
     *
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file to delete.
     * @return ApiResponse<DeleteVectorStoreFileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteVectorStoreFileWithHttpInfo(
        vectorStoreId: kotlin.String,
        fileId: kotlin.String,
    ): ApiResponse<DeleteVectorStoreFileResponse?> {
        val localVariableConfig =
            deleteVectorStoreFileRequestConfig(
                vectorStoreId = vectorStoreId,
                fileId = fileId,
            )

        return request<Unit, DeleteVectorStoreFileResponse>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation deleteVectorStoreFile
     *
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file to delete.
     * @return RequestConfig
     */
    fun deleteVectorStoreFileRequestConfig(
        vectorStoreId: kotlin.String,
        fileId: kotlin.String,
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path =
                "/vector_stores/{vector_store_id}/files/{file_id}"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    )
                    .replace(
                        "{" + "file_id" + "}",
                        encodeURIComponent(fileId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Retrieves a vector store.
     *
     * @param vectorStoreId The ID of the vector store to retrieve.
     * @return VectorStoreObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun getVectorStore(vectorStoreId: kotlin.String): VectorStoreObject {
        val localVarResponse =
            getVectorStoreWithHttpInfo(vectorStoreId = vectorStoreId)

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as VectorStoreObject
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Retrieves a vector store.
     *
     * @param vectorStoreId The ID of the vector store to retrieve.
     * @return ApiResponse<VectorStoreObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getVectorStoreWithHttpInfo(
        vectorStoreId: kotlin.String
    ): ApiResponse<VectorStoreObject?> {
        val localVariableConfig =
            getVectorStoreRequestConfig(vectorStoreId = vectorStoreId)

        return request<Unit, VectorStoreObject>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation getVectorStore
     *
     * @param vectorStoreId The ID of the vector store to retrieve.
     * @return RequestConfig
     */
    fun getVectorStoreRequestConfig(
        vectorStoreId: kotlin.String
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path =
                "/vector_stores/{vector_store_id}"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Retrieves a vector store file.
     *
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file being retrieved.
     * @return VectorStoreFileObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun getVectorStoreFile(
        vectorStoreId: kotlin.String,
        fileId: kotlin.String,
    ): VectorStoreFileObject {
        val localVarResponse =
            getVectorStoreFileWithHttpInfo(
                vectorStoreId = vectorStoreId,
                fileId = fileId,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as VectorStoreFileObject
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Retrieves a vector store file.
     *
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file being retrieved.
     * @return ApiResponse<VectorStoreFileObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getVectorStoreFileWithHttpInfo(
        vectorStoreId: kotlin.String,
        fileId: kotlin.String,
    ): ApiResponse<VectorStoreFileObject?> {
        val localVariableConfig =
            getVectorStoreFileRequestConfig(
                vectorStoreId = vectorStoreId,
                fileId = fileId,
            )

        return request<Unit, VectorStoreFileObject>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation getVectorStoreFile
     *
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file being retrieved.
     * @return RequestConfig
     */
    fun getVectorStoreFileRequestConfig(
        vectorStoreId: kotlin.String,
        fileId: kotlin.String,
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path =
                "/vector_stores/{vector_store_id}/files/{file_id}"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    )
                    .replace(
                        "{" + "file_id" + "}",
                        encodeURIComponent(fileId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Retrieves a vector store file batch.
     *
     * @param vectorStoreId The ID of the vector store that the file batch
     *   belongs to.
     * @param batchId The ID of the file batch being retrieved.
     * @return VectorStoreFileBatchObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun getVectorStoreFileBatch(
        vectorStoreId: kotlin.String,
        batchId: kotlin.String,
    ): VectorStoreFileBatchObject {
        val localVarResponse =
            getVectorStoreFileBatchWithHttpInfo(
                vectorStoreId = vectorStoreId,
                batchId = batchId,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data
                    as VectorStoreFileBatchObject
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Retrieves a vector store file batch.
     *
     * @param vectorStoreId The ID of the vector store that the file batch
     *   belongs to.
     * @param batchId The ID of the file batch being retrieved.
     * @return ApiResponse<VectorStoreFileBatchObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getVectorStoreFileBatchWithHttpInfo(
        vectorStoreId: kotlin.String,
        batchId: kotlin.String,
    ): ApiResponse<VectorStoreFileBatchObject?> {
        val localVariableConfig =
            getVectorStoreFileBatchRequestConfig(
                vectorStoreId = vectorStoreId,
                batchId = batchId,
            )

        return request<Unit, VectorStoreFileBatchObject>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation getVectorStoreFileBatch
     *
     * @param vectorStoreId The ID of the vector store that the file batch
     *   belongs to.
     * @param batchId The ID of the file batch being retrieved.
     * @return RequestConfig
     */
    fun getVectorStoreFileBatchRequestConfig(
        vectorStoreId: kotlin.String,
        batchId: kotlin.String,
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path =
                "/vector_stores/{vector_store_id}/file_batches/{batch_id}"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    )
                    .replace(
                        "{" + "batch_id" + "}",
                        encodeURIComponent(batchId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /** enum for parameter order */
    enum class OrderListFilesInVectorStoreBatch(val value: kotlin.String) {
        @Json(name = "asc") asc("asc"),
        @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the
         * value, and instead use the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are
         * different, and ensures that the client sends the correct enum values
         * to the server always.
         */
        override fun toString(): kotlin.String = "$value"
    }

    /** enum for parameter filter */
    enum class FilterListFilesInVectorStoreBatch(val value: kotlin.String) {
        @Json(name = "in_progress") in_progress("in_progress"),
        @Json(name = "completed") completed("completed"),
        @Json(name = "failed") failed("failed"),
        @Json(name = "cancelled") cancelled("cancelled");

        /**
         * Override [toString()] to avoid using the enum variable name as the
         * value, and instead use the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are
         * different, and ensures that the client sends the correct enum values
         * to the server always.
         */
        override fun toString(): kotlin.String = "$value"
    }

    /**
     * Returns a list of vector store files in a batch.
     *
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param batchId The ID of the file batch that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, starting with obj_foo,
     *   your subsequent call can include before&#x3D;obj_foo in order to fetch
     *   the previous page of the list. (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;,
     *   &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     *   (optional)
     * @return ListVectorStoreFilesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun listFilesInVectorStoreBatch(
        vectorStoreId: kotlin.String,
        batchId: kotlin.String,
        limit: kotlin.Int? = 20,
        order: OrderListFilesInVectorStoreBatch? =
            OrderListFilesInVectorStoreBatch.desc,
        after: kotlin.String? = null,
        before: kotlin.String? = null,
        filter: FilterListFilesInVectorStoreBatch? = null,
    ): ListVectorStoreFilesResponse {
        val localVarResponse =
            listFilesInVectorStoreBatchWithHttpInfo(
                vectorStoreId = vectorStoreId,
                batchId = batchId,
                limit = limit,
                order = order,
                after = after,
                before = before,
                filter = filter,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data
                    as ListVectorStoreFilesResponse
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Returns a list of vector store files in a batch.
     *
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param batchId The ID of the file batch that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, starting with obj_foo,
     *   your subsequent call can include before&#x3D;obj_foo in order to fetch
     *   the previous page of the list. (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;,
     *   &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     *   (optional)
     * @return ApiResponse<ListVectorStoreFilesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listFilesInVectorStoreBatchWithHttpInfo(
        vectorStoreId: kotlin.String,
        batchId: kotlin.String,
        limit: kotlin.Int?,
        order: OrderListFilesInVectorStoreBatch?,
        after: kotlin.String?,
        before: kotlin.String?,
        filter: FilterListFilesInVectorStoreBatch?,
    ): ApiResponse<ListVectorStoreFilesResponse?> {
        val localVariableConfig =
            listFilesInVectorStoreBatchRequestConfig(
                vectorStoreId = vectorStoreId,
                batchId = batchId,
                limit = limit,
                order = order,
                after = after,
                before = before,
                filter = filter,
            )

        return request<Unit, ListVectorStoreFilesResponse>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation listFilesInVectorStoreBatch
     *
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param batchId The ID of the file batch that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, starting with obj_foo,
     *   your subsequent call can include before&#x3D;obj_foo in order to fetch
     *   the previous page of the list. (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;,
     *   &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     *   (optional)
     * @return RequestConfig
     */
    fun listFilesInVectorStoreBatchRequestConfig(
        vectorStoreId: kotlin.String,
        batchId: kotlin.String,
        limit: kotlin.Int?,
        order: OrderListFilesInVectorStoreBatch?,
        after: kotlin.String?,
        before: kotlin.String?,
        filter: FilterListFilesInVectorStoreBatch?,
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap =
            mutableMapOf<
                    kotlin.String,
                    kotlin.collections.List<kotlin.String>,
                >()
                .apply {
                    if (limit != null) {
                        put("limit", listOf(limit.toString()))
                    }
                    if (order != null) {
                        put("order", listOf(order.value))
                    }
                    if (after != null) {
                        put("after", listOf(after.toString()))
                    }
                    if (before != null) {
                        put("before", listOf(before.toString()))
                    }
                    if (filter != null) {
                        put("filter", listOf(filter.value))
                    }
                }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path =
                "/vector_stores/{vector_store_id}/file_batches/{batch_id}/files"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    )
                    .replace(
                        "{" + "batch_id" + "}",
                        encodeURIComponent(batchId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /** enum for parameter order */
    enum class OrderListVectorStoreFiles(val value: kotlin.String) {
        @Json(name = "asc") asc("asc"),
        @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the
         * value, and instead use the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are
         * different, and ensures that the client sends the correct enum values
         * to the server always.
         */
        override fun toString(): kotlin.String = "$value"
    }

    /** enum for parameter filter */
    enum class FilterListVectorStoreFiles(val value: kotlin.String) {
        @Json(name = "in_progress") in_progress("in_progress"),
        @Json(name = "completed") completed("completed"),
        @Json(name = "failed") failed("failed"),
        @Json(name = "cancelled") cancelled("cancelled");

        /**
         * Override [toString()] to avoid using the enum variable name as the
         * value, and instead use the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are
         * different, and ensures that the client sends the correct enum values
         * to the server always.
         */
        override fun toString(): kotlin.String = "$value"
    }

    /**
     * Returns a list of vector store files.
     *
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, starting with obj_foo,
     *   your subsequent call can include before&#x3D;obj_foo in order to fetch
     *   the previous page of the list. (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;,
     *   &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     *   (optional)
     * @return ListVectorStoreFilesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun listVectorStoreFiles(
        vectorStoreId: kotlin.String,
        limit: kotlin.Int? = 20,
        order: OrderListVectorStoreFiles? = OrderListVectorStoreFiles.desc,
        after: kotlin.String? = null,
        before: kotlin.String? = null,
        filter: FilterListVectorStoreFiles? = null,
    ): ListVectorStoreFilesResponse {
        val localVarResponse =
            listVectorStoreFilesWithHttpInfo(
                vectorStoreId = vectorStoreId,
                limit = limit,
                order = order,
                after = after,
                before = before,
                filter = filter,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data
                    as ListVectorStoreFilesResponse
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Returns a list of vector store files.
     *
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, starting with obj_foo,
     *   your subsequent call can include before&#x3D;obj_foo in order to fetch
     *   the previous page of the list. (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;,
     *   &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     *   (optional)
     * @return ApiResponse<ListVectorStoreFilesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listVectorStoreFilesWithHttpInfo(
        vectorStoreId: kotlin.String,
        limit: kotlin.Int?,
        order: OrderListVectorStoreFiles?,
        after: kotlin.String?,
        before: kotlin.String?,
        filter: FilterListVectorStoreFiles?,
    ): ApiResponse<ListVectorStoreFilesResponse?> {
        val localVariableConfig =
            listVectorStoreFilesRequestConfig(
                vectorStoreId = vectorStoreId,
                limit = limit,
                order = order,
                after = after,
                before = before,
                filter = filter,
            )

        return request<Unit, ListVectorStoreFilesResponse>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation listVectorStoreFiles
     *
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, starting with obj_foo,
     *   your subsequent call can include before&#x3D;obj_foo in order to fetch
     *   the previous page of the list. (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;,
     *   &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     *   (optional)
     * @return RequestConfig
     */
    fun listVectorStoreFilesRequestConfig(
        vectorStoreId: kotlin.String,
        limit: kotlin.Int?,
        order: OrderListVectorStoreFiles?,
        after: kotlin.String?,
        before: kotlin.String?,
        filter: FilterListVectorStoreFiles?,
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap =
            mutableMapOf<
                    kotlin.String,
                    kotlin.collections.List<kotlin.String>,
                >()
                .apply {
                    if (limit != null) {
                        put("limit", listOf(limit.toString()))
                    }
                    if (order != null) {
                        put("order", listOf(order.value))
                    }
                    if (after != null) {
                        put("after", listOf(after.toString()))
                    }
                    if (before != null) {
                        put("before", listOf(before.toString()))
                    }
                    if (filter != null) {
                        put("filter", listOf(filter.value))
                    }
                }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path =
                "/vector_stores/{vector_store_id}/files"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /** enum for parameter order */
    enum class OrderListVectorStores(val value: kotlin.String) {
        @Json(name = "asc") asc("asc"),
        @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the
         * value, and instead use the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are
         * different, and ensures that the client sends the correct enum values
         * to the server always.
         */
        override fun toString(): kotlin.String = "$value"
    }

    /**
     * Returns a list of vector stores.
     *
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, starting with obj_foo,
     *   your subsequent call can include before&#x3D;obj_foo in order to fetch
     *   the previous page of the list. (optional)
     * @return ListVectorStoresResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun listVectorStores(
        limit: kotlin.Int? = 20,
        order: OrderListVectorStores? = OrderListVectorStores.desc,
        after: kotlin.String? = null,
        before: kotlin.String? = null,
    ): ListVectorStoresResponse {
        val localVarResponse =
            listVectorStoresWithHttpInfo(
                limit = limit,
                order = order,
                after = after,
                before = before,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data
                    as ListVectorStoresResponse
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Returns a list of vector stores.
     *
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, starting with obj_foo,
     *   your subsequent call can include before&#x3D;obj_foo in order to fetch
     *   the previous page of the list. (optional)
     * @return ApiResponse<ListVectorStoresResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listVectorStoresWithHttpInfo(
        limit: kotlin.Int?,
        order: OrderListVectorStores?,
        after: kotlin.String?,
        before: kotlin.String?,
    ): ApiResponse<ListVectorStoresResponse?> {
        val localVariableConfig =
            listVectorStoresRequestConfig(
                limit = limit,
                order = order,
                after = after,
                before = before,
            )

        return request<Unit, ListVectorStoresResponse>(localVariableConfig)
    }

    /**
     * To obtain the request config of the operation listVectorStores
     *
     * @param limit A limit on the number of objects to be returned. Limit can
     *   range between 1 and 100, and the default is 20. (optional, default
     *   to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the
     *   objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for
     *   descending order. (optional, default to desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, ending with obj_foo, your
     *   subsequent call can include after&#x3D;obj_foo in order to fetch the
     *   next page of the list. (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an
     *   object ID that defines your place in the list. For instance, if you
     *   make a list request and receive 100 objects, starting with obj_foo,
     *   your subsequent call can include before&#x3D;obj_foo in order to fetch
     *   the previous page of the list. (optional)
     * @return RequestConfig
     */
    fun listVectorStoresRequestConfig(
        limit: kotlin.Int?,
        order: OrderListVectorStores?,
        after: kotlin.String?,
        before: kotlin.String?,
    ): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap =
            mutableMapOf<
                    kotlin.String,
                    kotlin.collections.List<kotlin.String>,
                >()
                .apply {
                    if (limit != null) {
                        put("limit", listOf(limit.toString()))
                    }
                    if (order != null) {
                        put("order", listOf(order.value))
                    }
                    if (after != null) {
                        put("after", listOf(after.toString()))
                    }
                    if (before != null) {
                        put("before", listOf(before.toString()))
                    }
                }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vector_stores",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    /**
     * Modifies a vector store.
     *
     * @param vectorStoreId The ID of the vector store to modify.
     * @param updateVectorStoreRequest
     * @return VectorStoreObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational
     *   or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(
        IllegalStateException::class,
        IOException::class,
        UnsupportedOperationException::class,
        ClientException::class,
        ServerException::class,
    )
    fun modifyVectorStore(
        vectorStoreId: kotlin.String,
        updateVectorStoreRequest: UpdateVectorStoreRequest,
    ): VectorStoreObject {
        val localVarResponse =
            modifyVectorStoreWithHttpInfo(
                vectorStoreId = vectorStoreId,
                updateVectorStoreRequest = updateVectorStoreRequest,
            )

        return when (localVarResponse.responseType) {
            ResponseType.Success ->
                (localVarResponse as Success<*>).data as VectorStoreObject
            ResponseType.Informational ->
                throw UnsupportedOperationException(
                    "Client does not support Informational responses."
                )
            ResponseType.Redirection ->
                throw UnsupportedOperationException(
                    "Client does not support Redirection responses."
                )
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException(
                    "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException(
                    "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
                    localVarError.statusCode,
                    localVarResponse,
                )
            }
        }
    }

    /**
     * Modifies a vector store.
     *
     * @param vectorStoreId The ID of the vector store to modify.
     * @param updateVectorStoreRequest
     * @return ApiResponse<VectorStoreObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun modifyVectorStoreWithHttpInfo(
        vectorStoreId: kotlin.String,
        updateVectorStoreRequest: UpdateVectorStoreRequest,
    ): ApiResponse<VectorStoreObject?> {
        val localVariableConfig =
            modifyVectorStoreRequestConfig(
                vectorStoreId = vectorStoreId,
                updateVectorStoreRequest = updateVectorStoreRequest,
            )

        return request<UpdateVectorStoreRequest, VectorStoreObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation modifyVectorStore
     *
     * @param vectorStoreId The ID of the vector store to modify.
     * @param updateVectorStoreRequest
     * @return RequestConfig
     */
    fun modifyVectorStoreRequestConfig(
        vectorStoreId: kotlin.String,
        updateVectorStoreRequest: UpdateVectorStoreRequest,
    ): RequestConfig<UpdateVectorStoreRequest> {
        val localVariableBody = updateVectorStoreRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path =
                "/vector_stores/{vector_store_id}"
                    .replace(
                        "{" + "vector_store_id" + "}",
                        encodeURIComponent(vectorStoreId.toString()),
                    ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody,
        )
    }

    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder()
            .scheme("http")
            .host("localhost")
            .addPathSegment(uriComponent)
            .build()
            .encodedPathSegments[0]
}
